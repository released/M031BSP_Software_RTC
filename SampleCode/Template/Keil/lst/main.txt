; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\main.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M031\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\main.crf ..\main.c]
                          THUMB

                          AREA ||i.Emulate_EEPROM||, CODE, READONLY, ALIGN=2

                  Emulate_EEPROM PROC
;;;224    
;;;225    void Emulate_EEPROM(void)
000000  b510              PUSH     {r4,lr}
;;;226    {
;;;227        SYS_UnlockReg();
000002  f7fffffe          BL       SYS_UnlockReg
;;;228    
;;;229        /* Enable FMC ISP function */
;;;230        FMC_Open();
000006  f7fffffe          BL       FMC_Open
;;;231    
;;;232        if (set_data_flash_base(DATA_FLASH_OFFSET) < 0)
00000a  200f              MOVS     r0,#0xf
00000c  0280              LSLS     r0,r0,#10
00000e  f7fffffe          BL       set_data_flash_base
000012  2800              CMP      r0,#0
000014  da02              BGE      |L1.28|
;;;233        {
;;;234            printf("Failed to set Data Flash base address!\r\n");
000016  a005              ADR      r0,|L1.44|
000018  f7fffffe          BL       __2printf
                  |L1.28|
;;;235        }
;;;236    
;;;237    	/* Test Init_EEPROM() */
;;;238    	Init_EEPROM(DATA_FLASH_AMOUNT, DATA_FLASH_PAGE);
00001c  2102              MOVS     r1,#2
00001e  2010              MOVS     r0,#0x10
000020  f7fffffe          BL       Init_EEPROM
;;;239    	Search_Valid_Page();	
000024  f7fffffe          BL       Search_Valid_Page
;;;240    }
000028  bd10              POP      {r4,pc}
;;;241    
                          ENDP

00002a  0000              DCW      0x0000
                  |L1.44|
00002c  4661696c          DCB      "Failed to set Data Flash base address!\r\n",0
000030  65642074
000034  6f207365
000038  74204461
00003c  74612046
000040  6c617368
000044  20626173
000048  65206164
00004c  64726573
000050  73210d0a
000054  00      
000055  00                DCB      0
000056  00                DCB      0
000057  00                DCB      0

                          AREA ||i.GPIO_Init||, CODE, READONLY, ALIGN=2

                  GPIO_Init PROC
;;;357    
;;;358    void GPIO_Init (void)
000000  b510              PUSH     {r4,lr}
;;;359    {
;;;360        GPIO_SetMode(PB, BIT14, GPIO_MODE_OUTPUT);
000002  2201              MOVS     r2,#1
000004  0391              LSLS     r1,r2,#14
000006  4802              LDR      r0,|L2.16|
000008  f7fffffe          BL       GPIO_SetMode
;;;361    }
00000c  bd10              POP      {r4,pc}
;;;362    
                          ENDP

00000e  0000              DCW      0x0000
                  |L2.16|
                          DCD      0x40004040

                          AREA ||i.GetDateTimeFromFlash||, CODE, READONLY, ALIGN=2

                  GetDateTimeFromFlash PROC
;;;92     
;;;93     void GetDateTimeFromFlash(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;94     {
;;;95     	uint8_t		rtc_temp = 0;
000002  2000              MOVS     r0,#0
000004  4669              MOV      r1,sp
000006  7008              STRB     r0,[r1,#0]
;;;96     	uint8_t 	rtc_msb = 0;
000008  7108              STRB     r0,[r1,#4]
;;;97     
;;;98     	Read_Data(DATA_FALSH_IDX_RTC_YEAR, &rtc_temp);
00000a  2001              MOVS     r0,#1
00000c  f7fffffe          BL       Read_Data
;;;99     	Read_Data(DATA_FALSH_IDX_RTC_YEAR+1, &rtc_msb);
000010  a901              ADD      r1,sp,#4
000012  2002              MOVS     r0,#2
000014  f7fffffe          BL       Read_Data
;;;100    	g_year = rtc_msb << 8 | rtc_temp;
000018  4669              MOV      r1,sp
00001a  7908              LDRB     r0,[r1,#4]
00001c  7809              LDRB     r1,[r1,#0]
00001e  0202              LSLS     r2,r0,#8
000020  430a              ORRS     r2,r2,r1
000022  4c25              LDR      r4,|L3.184|
;;;101    	if ((rtc_msb == 0xFF) || (rtc_temp == 0xFF))
000024  28ff              CMP      r0,#0xff
000026  60e2              STR      r2,[r4,#0xc]  ; g_year
000028  d001              BEQ      |L3.46|
00002a  29ff              CMP      r1,#0xff
00002c  d101              BNE      |L3.50|
                  |L3.46|
;;;102    	{
;;;103    		g_year = RTC_DEFAULT_YEAR;
00002e  4823              LDR      r0,|L3.188|
000030  60e0              STR      r0,[r4,#0xc]  ; g_year
                  |L3.50|
;;;104    	}
;;;105    
;;;106    	Read_Data(DATA_FALSH_IDX_RTC_MONTH, &rtc_temp);
000032  4669              MOV      r1,sp
000034  2003              MOVS     r0,#3
000036  f7fffffe          BL       Read_Data
;;;107    	g_month = rtc_temp;
00003a  4668              MOV      r0,sp
00003c  7800              LDRB     r0,[r0,#0]
00003e  7060              STRB     r0,[r4,#1]
;;;108    	if (g_month == 0xFF)
000040  28ff              CMP      r0,#0xff
000042  d101              BNE      |L3.72|
;;;109    	{
;;;110    		g_month = RTC_DEFAULT_MONTH;
000044  2004              MOVS     r0,#4
000046  7060              STRB     r0,[r4,#1]
                  |L3.72|
;;;111    	}
;;;112    
;;;113    	Read_Data(DATA_FALSH_IDX_RTC_DAY, &rtc_temp);
000048  4669              MOV      r1,sp
00004a  2004              MOVS     r0,#4
00004c  f7fffffe          BL       Read_Data
;;;114    	g_day = rtc_temp;
000050  4668              MOV      r0,sp
000052  7800              LDRB     r0,[r0,#0]
000054  70a0              STRB     r0,[r4,#2]
;;;115    	if (g_day == 0xFF)
000056  28ff              CMP      r0,#0xff
000058  d101              BNE      |L3.94|
;;;116    	{
;;;117    		g_day = RTC_DEFAULT_DAY;
00005a  201b              MOVS     r0,#0x1b
00005c  70a0              STRB     r0,[r4,#2]
                  |L3.94|
;;;118    	}	
;;;119    
;;;120    	Read_Data(DATA_FALSH_IDX_RTC_WEEKLY, &rtc_temp);
00005e  4669              MOV      r1,sp
000060  2005              MOVS     r0,#5
000062  f7fffffe          BL       Read_Data
;;;121    	g_weekly = rtc_temp;
000066  4668              MOV      r0,sp
000068  7800              LDRB     r0,[r0,#0]
00006a  70e0              STRB     r0,[r4,#3]
;;;122    	if (g_weekly == 0xFF)
00006c  28ff              CMP      r0,#0xff
00006e  d101              BNE      |L3.116|
;;;123    	{
;;;124    		g_weekly = RTC_DEFAULT_WEEKLY;
000070  2001              MOVS     r0,#1
000072  70e0              STRB     r0,[r4,#3]
                  |L3.116|
;;;125    	}
;;;126    
;;;127    
;;;128    	Read_Data(DATA_FALSH_IDX_RTC_HOUR, &rtc_temp);
000074  4669              MOV      r1,sp
000076  2006              MOVS     r0,#6
000078  f7fffffe          BL       Read_Data
;;;129    	hour = rtc_temp;
00007c  4668              MOV      r0,sp
00007e  7800              LDRB     r0,[r0,#0]
000080  7120              STRB     r0,[r4,#4]
;;;130    	if (hour == 0xFF)
000082  28ff              CMP      r0,#0xff
000084  d101              BNE      |L3.138|
;;;131    	{
;;;132    		hour = RTC_DEFAULT_HOUR;
000086  200d              MOVS     r0,#0xd
000088  7120              STRB     r0,[r4,#4]
                  |L3.138|
;;;133    	}
;;;134    	
;;;135    	Read_Data(DATA_FALSH_IDX_RTC_MIN, &rtc_temp);
00008a  4669              MOV      r1,sp
00008c  2007              MOVS     r0,#7
00008e  f7fffffe          BL       Read_Data
;;;136    	min = rtc_temp;
000092  4668              MOV      r0,sp
000094  7800              LDRB     r0,[r0,#0]
000096  7160              STRB     r0,[r4,#5]
;;;137    	if (min == 0xFF)
000098  28ff              CMP      r0,#0xff
00009a  d101              BNE      |L3.160|
;;;138    	{
;;;139    		min = RTC_DEFAULT_MIN;
00009c  203b              MOVS     r0,#0x3b
00009e  7160              STRB     r0,[r4,#5]
                  |L3.160|
;;;140    	}
;;;141    
;;;142    	Read_Data(DATA_FALSH_IDX_RTC_SEC, &rtc_temp);
0000a0  4669              MOV      r1,sp
0000a2  2008              MOVS     r0,#8
0000a4  f7fffffe          BL       Read_Data
;;;143    	sec = rtc_temp;	
0000a8  4668              MOV      r0,sp
0000aa  7800              LDRB     r0,[r0,#0]
0000ac  71a0              STRB     r0,[r4,#6]
;;;144    	if (sec == 0xFF)
0000ae  28ff              CMP      r0,#0xff
0000b0  d101              BNE      |L3.182|
;;;145    	{
;;;146    		sec = RTC_DEFAULT_SEC;
0000b2  201e              MOVS     r0,#0x1e
0000b4  71a0              STRB     r0,[r4,#6]
                  |L3.182|
;;;147    	}
;;;148    	
;;;149    }
0000b6  bd1c              POP      {r2-r4,pc}
;;;150    
                          ENDP

                  |L3.184|
                          DCD      ||.data||
                  |L3.188|
                          DCD      0x000007e4

                          AREA ||i.RTC_Process||, CODE, READONLY, ALIGN=1

                  RTC_Process PROC
;;;304    
;;;305    void RTC_Process(void)
000000  b510              PUSH     {r4,lr}
;;;306    {
;;;307    	SoftwareRTC();
000002  f7fffffe          BL       SoftwareRTC
;;;308    	SoftwareYMD();
000006  f7fffffe          BL       SoftwareYMD
;;;309    }
00000a  bd10              POP      {r4,pc}
;;;310    
                          ENDP


                          AREA ||i.SYS_Init||, CODE, READONLY, ALIGN=2

                  SYS_Init PROC
;;;444    
;;;445    void SYS_Init(void)
000000  b510              PUSH     {r4,lr}
;;;446    {
;;;447        /* Unlock protected registers */
;;;448        SYS_UnlockReg();
000002  f7fffffe          BL       SYS_UnlockReg
;;;449    
;;;450        /* Enable HIRC clock (Internal RC 48MHz) */
;;;451        CLK_EnableXtalRC(CLK_PWRCTL_HIRCEN_Msk);
000006  2004              MOVS     r0,#4
000008  f7fffffe          BL       CLK_EnableXtalRC
;;;452    //    CLK_EnableXtalRC(CLK_PWRCTL_HXTEN_Msk);
;;;453    	
;;;454        /* Wait for HIRC clock ready */
;;;455        CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
00000c  2010              MOVS     r0,#0x10
00000e  f7fffffe          BL       CLK_WaitClockReady
;;;456    //    CLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk);
;;;457    	
;;;458        /* Select HCLK clock source as HIRC and HCLK source divider as 1 */
;;;459        CLK_SetHCLK(CLK_CLKSEL0_HCLKSEL_HIRC, CLK_CLKDIV0_HCLK(1));
000012  2100              MOVS     r1,#0
000014  2007              MOVS     r0,#7
000016  f7fffffe          BL       CLK_SetHCLK
;;;460    
;;;461        /* Enable UART0 clock */
;;;462        CLK_EnableModuleClock(UART0_MODULE);
00001a  4c16              LDR      r4,|L5.116|
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       CLK_EnableModuleClock
;;;463        CLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART0SEL_PCLK0, CLK_CLKDIV0_UART0(1));
000022  2101              MOVS     r1,#1
000024  2200              MOVS     r2,#0
000026  0689              LSLS     r1,r1,#26
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       CLK_SetModuleClock
;;;464    
;;;465        CLK_EnableModuleClock(TMR2_MODULE);
00002e  4c12              LDR      r4,|L5.120|
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       CLK_EnableModuleClock
;;;466        CLK_SetModuleClock(TMR2_MODULE, CLK_CLKSEL1_TMR2SEL_PCLK1, 0);
000036  2200              MOVS     r2,#0
000038  03e1              LSLS     r1,r4,#15
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       CLK_SetModuleClock
;;;467    	
;;;468        CLK_EnableModuleClock(TMR3_MODULE);
000040  4c0e              LDR      r4,|L5.124|
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       CLK_EnableModuleClock
;;;469        CLK_SetModuleClock(TMR3_MODULE, CLK_CLKSEL1_TMR3SEL_PCLK1, 0);
000048  2101              MOVS     r1,#1
00004a  2200              MOVS     r2,#0
00004c  0549              LSLS     r1,r1,#21
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       CLK_SetModuleClock
;;;470    
;;;471    
;;;472        /* Update System Core Clock */
;;;473        SystemCoreClockUpdate();
000054  f7fffffe          BL       SystemCoreClockUpdate
;;;474    
;;;475    	/*----------------------------------------------------*/
;;;476        /* Set PB multi-function pins for UART0 RXD=PB.12 and TXD=PB.13 */
;;;477        SYS->GPB_MFPH = (SYS->GPB_MFPH & ~(SYS_GPB_MFPH_PB12MFP_Msk | SYS_GPB_MFPH_PB13MFP_Msk))    |       \
000058  07a0              LSLS     r0,r4,#30
00005a  6bc1              LDR      r1,[r0,#0x3c]
00005c  22ff              MOVS     r2,#0xff
00005e  0412              LSLS     r2,r2,#16
000060  4391              BICS     r1,r1,r2
000062  2233              MOVS     r2,#0x33
000064  0452              LSLS     r2,r2,#17
000066  1889              ADDS     r1,r1,r2
000068  63c1              STR      r1,[r0,#0x3c]
00006a  4905              LDR      r1,|L5.128|
00006c  2000              MOVS     r0,#0
00006e  6008              STR      r0,[r1,#0]
;;;478                        (SYS_GPB_MFPH_PB12MFP_UART0_RXD | SYS_GPB_MFPH_PB13MFP_UART0_TXD);
;;;479    
;;;480    
;;;481        /* Lock protected registers */
;;;482        SYS_LockReg();
;;;483    }
000070  bd10              POP      {r4,pc}
;;;484    
                          ENDP

000072  0000              DCW      0x0000
                  |L5.116|
                          DCD      0x5f803d10
                  |L5.120|
                          DCD      0x5f000004
                  |L5.124|
                          DCD      0x5f400005
                  |L5.128|
                          DCD      0x40000100

                          AREA ||i.SYS_UnlockReg||, CODE, READONLY, ALIGN=2

                  SYS_UnlockReg PROC
;;;1341     */
;;;1342   __STATIC_INLINE void SYS_UnlockReg(void)
000000  b510              PUSH     {r4,lr}
;;;1343   {
;;;1344       do {
;;;1345           SYS->REGLCTL = 0x59;
000002  2159              MOVS     r1,#0x59
000004  4804              LDR      r0,|L6.24|
;;;1346           SYS->REGLCTL = 0x16;
000006  2216              MOVS     r2,#0x16
;;;1347           SYS->REGLCTL = 0x88;
000008  2388              MOVS     r3,#0x88
                  |L6.10|
00000a  6001              STR      r1,[r0,#0]            ;1345
00000c  6002              STR      r2,[r0,#0]            ;1346
00000e  6003              STR      r3,[r0,#0]
;;;1348       } while (SYS->REGLCTL == 0);
000010  6804              LDR      r4,[r0,#0]
000012  2c00              CMP      r4,#0
000014  d0f9              BEQ      |L6.10|
;;;1349   }
000016  bd10              POP      {r4,pc}
;;;1350   
                          ENDP

                  |L6.24|
                          DCD      0x40000100

                          AREA ||i.SaveDateTimeToFlash||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                  SaveDateTimeToFlash PROC
;;;150    
;;;151    void SaveDateTimeToFlash(void)
000000  b510              PUSH     {r4,lr}
;;;152    {
;;;153    	if (is_flag_set(flag_Record_Data))
000002  4c19              LDR      r4,|L7.104|
000004  7820              LDRB     r0,[r4,#0]  ; BitFlag
000006  0641              LSLS     r1,r0,#25
000008  d52d              BPL      |L7.102|
;;;154    	{
;;;155    		set_flag(flag_Record_Data , DISABLE);
00000a  21bf              MOVS     r1,#0xbf
00000c  4008              ANDS     r0,r0,r1
00000e  7020              STRB     r0,[r4,#0]
;;;156    
;;;157    		Write_Data(DATA_FALSH_IDX_RTC_YEAR , LOBYTE(g_year));
000010  7b21              LDRB     r1,[r4,#0xc]  ; g_year
000012  2001              MOVS     r0,#1
000014  f7fffffe          BL       Write_Data
;;;158    		Write_Data(DATA_FALSH_IDX_RTC_YEAR+1 , HIBYTE(g_year));
000018  89a0              LDRH     r0,[r4,#0xc]  ; g_year
00001a  0400              LSLS     r0,r0,#16
00001c  0e01              LSRS     r1,r0,#24
00001e  2002              MOVS     r0,#2
000020  f7fffffe          BL       Write_Data
;;;159    
;;;160    		Write_Data(DATA_FALSH_IDX_RTC_MONTH , g_month);
000024  7861              LDRB     r1,[r4,#1]  ; g_month
000026  2003              MOVS     r0,#3
000028  f7fffffe          BL       Write_Data
;;;161    		Write_Data(DATA_FALSH_IDX_RTC_DAY , g_day);
00002c  78a1              LDRB     r1,[r4,#2]  ; g_day
00002e  2004              MOVS     r0,#4
000030  f7fffffe          BL       Write_Data
;;;162    		Write_Data(DATA_FALSH_IDX_RTC_WEEKLY , g_weekly);
000034  78e1              LDRB     r1,[r4,#3]  ; g_weekly
000036  2005              MOVS     r0,#5
000038  f7fffffe          BL       Write_Data
;;;163    		
;;;164    		Write_Data(DATA_FALSH_IDX_RTC_HOUR , hour);
00003c  7921              LDRB     r1,[r4,#4]  ; hour
00003e  2006              MOVS     r0,#6
000040  f7fffffe          BL       Write_Data
;;;165    		Write_Data(DATA_FALSH_IDX_RTC_MIN , min);
000044  7961              LDRB     r1,[r4,#5]  ; min
000046  2007              MOVS     r0,#7
000048  f7fffffe          BL       Write_Data
;;;166    		Write_Data(DATA_FALSH_IDX_RTC_SEC , sec);	
00004c  79a1              LDRB     r1,[r4,#6]  ; sec
00004e  2008              MOVS     r0,#8
000050  f7fffffe          BL       Write_Data
;;;167    		
;;;168    		/* Disable FMC ISP function */
;;;169    		FMC_Close();
000054  f7fffffe          BL       FMC_Close
000058  4904              LDR      r1,|L7.108|
00005a  2000              MOVS     r0,#0
00005c  6008              STR      r0,[r1,#0]
;;;170    
;;;171    		/* Lock protected registers */
;;;172    		SYS_LockReg();
;;;173    
;;;174    		printf(" \r\n%s ! \r\n\r\n" , __FUNCTION__);
00005e  4904              LDR      r1,|L7.112|
000060  a004              ADR      r0,|L7.116|
000062  f7fffffe          BL       __2printf
                  |L7.102|
;;;175    	}
;;;176    }
000066  bd10              POP      {r4,pc}
;;;177    
                          ENDP

                  |L7.104|
                          DCD      ||.data||
                  |L7.108|
                          DCD      0x40000100
                  |L7.112|
                          DCD      ||.constdata||
                  |L7.116|
000074  200d0a25          DCB      " \r\n%s ! \r\n\r\n",0
000078  73202120
00007c  0d0a0d0a
000080  00      
000081  00                DCB      0
000082  00                DCB      0
000083  00                DCB      0

                          AREA ||i.SoftwareRTC||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  SoftwareRTC PROC
;;;246    
;;;247    void SoftwareRTC(void)
000000  b570              PUSH     {r4-r6,lr}
;;;248    {
;;;249    	if (!is_flag_set(flag_RTC))	//(flag_RTC==0)
000002  4c1a              LDR      r4,|L8.108|
000004  7825              LDRB     r5,[r4,#0]  ; BitFlag
000006  06a8              LSLS     r0,r5,#26
000008  d52e              BPL      |L8.104|
;;;250    		return;
;;;251    	sec++;
00000a  79a0              LDRB     r0,[r4,#6]  ; sec
;;;252    
;;;253    	if ((sec%10) == 0 )	//record data per 10 sec	
00000c  210a              MOVS     r1,#0xa
00000e  1c40              ADDS     r0,r0,#1              ;251
000010  b2c0              UXTB     r0,r0                 ;251
000012  71a0              STRB     r0,[r4,#6]            ;251
000014  4606              MOV      r6,r0                 ;251
000016  f7fffffe          BL       __aeabi_uidivmod
00001a  2900              CMP      r1,#0
00001c  d102              BNE      |L8.36|
;;;254    	{
;;;255    		set_flag(flag_Record_Data , ENABLE);	
00001e  2040              MOVS     r0,#0x40
000020  4305              ORRS     r5,r5,r0
000022  7025              STRB     r5,[r4,#0]
                  |L8.36|
000024  2000              MOVS     r0,#0
;;;256    	}
;;;257    	
;;;258    	if(sec==60)
000026  2e3c              CMP      r6,#0x3c
000028  d103              BNE      |L8.50|
;;;259    	{
;;;260    //		set_flag(flag_Record_Data , ENABLE);	//record data per 60 sec
;;;261    	
;;;262    		sec=0;			
00002a  71a0              STRB     r0,[r4,#6]
;;;263    		min++;			
00002c  7961              LDRB     r1,[r4,#5]  ; min
00002e  1c49              ADDS     r1,r1,#1
000030  7161              STRB     r1,[r4,#5]
                  |L8.50|
;;;264    	}
;;;265    	if(min==60)
000032  7961              LDRB     r1,[r4,#5]  ; min
000034  293c              CMP      r1,#0x3c
000036  d103              BNE      |L8.64|
;;;266    	{
;;;267    		min=0;
000038  7160              STRB     r0,[r4,#5]
;;;268    		hour++;			
00003a  7921              LDRB     r1,[r4,#4]  ; hour
00003c  1c49              ADDS     r1,r1,#1
00003e  7121              STRB     r1,[r4,#4]
                  |L8.64|
;;;269    	}
;;;270    	if(hour==24)
000040  7921              LDRB     r1,[r4,#4]  ; hour
000042  2918              CMP      r1,#0x18
000044  d106              BNE      |L8.84|
;;;271    	{
;;;272    		hour=0;
000046  7120              STRB     r0,[r4,#4]
;;;273    		g_day++;
000048  78a0              LDRB     r0,[r4,#2]  ; g_day
00004a  1c40              ADDS     r0,r0,#1
00004c  70a0              STRB     r0,[r4,#2]
;;;274    		g_weekly++;
00004e  78e0              LDRB     r0,[r4,#3]  ; g_weekly
000050  1c40              ADDS     r0,r0,#1
000052  70e0              STRB     r0,[r4,#3]
                  |L8.84|
;;;275    	}
;;;276    	printf("hr.:%d :min: %d: sec: %d\n\r",hour,min,sec);
000054  79a3              LDRB     r3,[r4,#6]  ; sec
000056  7962              LDRB     r2,[r4,#5]  ; min
000058  7921              LDRB     r1,[r4,#4]  ; hour
00005a  a005              ADR      r0,|L8.112|
00005c  f7fffffe          BL       __2printf
;;;277    	set_flag(flag_RTC,DISABLE);//flag_RTC=0;
000060  7820              LDRB     r0,[r4,#0]  ; BitFlag
000062  21df              MOVS     r1,#0xdf
000064  4008              ANDS     r0,r0,r1
000066  7020              STRB     r0,[r4,#0]
                  |L8.104|
;;;278    }
000068  bd70              POP      {r4-r6,pc}
;;;279    
                          ENDP

00006a  0000              DCW      0x0000
                  |L8.108|
                          DCD      ||.data||
                  |L8.112|
000070  68722e3a          DCB      "hr.:%d :min: %d: sec: %d\n\r",0
000074  2564203a
000078  6d696e3a
00007c  2025643a
000080  20736563
000084  3a202564
000088  0a0d00  
00008b  00                DCB      0

                          AREA ||i.SoftwareYMD||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  SoftwareYMD PROC
;;;279    
;;;280    void SoftwareYMD(void)
000000  b510              PUSH     {r4,lr}
;;;281    {	
000002  b08e              SUB      sp,sp,#0x38
;;;282    	int days[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
000004  2230              MOVS     r2,#0x30
000006  4918              LDR      r1,|L9.104|
000008  a801              ADD      r0,sp,#4
00000a  f7fffffe          BL       __aeabi_memcpy4
;;;283    	days[1] += isLeapYear(g_year);
00000e  4c17              LDR      r4,|L9.108|
000010  68e0              LDR      r0,[r4,#0xc]  ; g_year
000012  f7fffffe          BL       isLeapYear
000016  9902              LDR      r1,[sp,#8]
000018  1840              ADDS     r0,r0,r1
;;;284    	if(g_day==g_day_old)
00001a  9002              STR      r0,[sp,#8]
00001c  78a0              LDRB     r0,[r4,#2]  ; g_day
00001e  79e1              LDRB     r1,[r4,#7]  ; g_day_old
000020  4288              CMP      r0,r1
000022  d01f              BEQ      |L9.100|
;;;285    		return;
;;;286    	g_day_old=g_day;
000024  71e0              STRB     r0,[r4,#7]
;;;287    	if(g_day>days[g_month-1])
000026  7861              LDRB     r1,[r4,#1]  ; g_month
000028  ab01              ADD      r3,sp,#4
00002a  008a              LSLS     r2,r1,#2
00002c  18d2              ADDS     r2,r2,r3
00002e  3a80              SUBS     r2,r2,#0x80
;;;288    	{
;;;289    		g_day=1;
000030  6fd3              LDR      r3,[r2,#0x7c]
000032  2201              MOVS     r2,#1
000034  4283              CMP      r3,r0                 ;287
000036  da02              BGE      |L9.62|
000038  70a2              STRB     r2,[r4,#2]
00003a  1c49              ADDS     r1,r1,#1
;;;290    		g_month++;
00003c  7061              STRB     r1,[r4,#1]
                  |L9.62|
;;;291    
;;;292    	}
;;;293    
;;;294    	if(g_weekly>7)//7 is sum day
00003e  78e0              LDRB     r0,[r4,#3]  ; g_weekly
000040  2807              CMP      r0,#7
000042  d900              BLS      |L9.70|
;;;295    		g_weekly=1;
000044  70e2              STRB     r2,[r4,#3]
                  |L9.70|
;;;296    
;;;297    	if(g_month>12)
000046  b2c8              UXTB     r0,r1
000048  280c              CMP      r0,#0xc
00004a  d903              BLS      |L9.84|
;;;298    	{
;;;299    		g_month=1;
00004c  7062              STRB     r2,[r4,#1]
;;;300    		g_year++;
00004e  68e0              LDR      r0,[r4,#0xc]  ; g_year
000050  1c40              ADDS     r0,r0,#1
000052  60e0              STR      r0,[r4,#0xc]  ; g_year
                  |L9.84|
;;;301    	}
;;;302    	printf("Y:%d, M:%d, D:%d, Weekly:%d\n\r",g_year,g_month,g_day,g_weekly);
000054  78e0              LDRB     r0,[r4,#3]  ; g_weekly
000056  9000              STR      r0,[sp,#0]
000058  78a3              LDRB     r3,[r4,#2]  ; g_day
00005a  7862              LDRB     r2,[r4,#1]  ; g_month
00005c  a004              ADR      r0,|L9.112|
00005e  68e1              LDR      r1,[r4,#0xc]  ; g_year
000060  f7fffffe          BL       __2printf
                  |L9.100|
;;;303    }
000064  b00e              ADD      sp,sp,#0x38
000066  bd10              POP      {r4,pc}
;;;304    
                          ENDP

                  |L9.104|
                          DCD      ||.constdata||+0x14
                  |L9.108|
                          DCD      ||.data||
                  |L9.112|
000070  593a2564          DCB      "Y:%d, M:%d, D:%d, Weekly:%d\n\r",0
000074  2c204d3a
000078  25642c20
00007c  443a2564
000080  2c205765
000084  656b6c79
000088  3a25640a
00008c  0d00    
00008e  00                DCB      0
00008f  00                DCB      0

                          AREA ||i.TIMER2_Init||, CODE, READONLY, ALIGN=2

                  TIMER2_Init PROC
;;;393    
;;;394    void TIMER2_Init(void)
000000  b510              PUSH     {r4,lr}
;;;395    {
;;;396        TIMER_Open(TIMER2, TIMER_PERIODIC_MODE, 1);
000002  4c09              LDR      r4,|L10.40|
000004  2201              MOVS     r2,#1
000006  06d1              LSLS     r1,r2,#27
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       TIMER_Open
00000e  6820              LDR      r0,[r4,#0]
000010  0461              LSLS     r1,r4,#17
000012  4308              ORRS     r0,r0,r1
000014  6020              STR      r0,[r4,#0]
000016  14c8              ASRS     r0,r1,#19
000018  4904              LDR      r1,|L10.44|
00001a  6008              STR      r0,[r1,#0]
00001c  6820              LDR      r0,[r4,#0]
00001e  0589              LSLS     r1,r1,#22
000020  4308              ORRS     r0,r0,r1
000022  6020              STR      r0,[r4,#0]
;;;397        TIMER_EnableInt(TIMER2);
;;;398        NVIC_EnableIRQ(TMR2_IRQn);	
;;;399        TIMER_Start(TIMER2);
;;;400    }
000024  bd10              POP      {r4,pc}
;;;401    
                          ENDP

000026  0000              DCW      0x0000
                  |L10.40|
                          DCD      0x40051000
                  |L10.44|
                          DCD      0xe000e100

                          AREA ||i.TIMER3_Init||, CODE, READONLY, ALIGN=2

                  TIMER3_Init PROC
;;;376    
;;;377    void TIMER3_Init(void)
000000  b510              PUSH     {r4,lr}
;;;378    {
;;;379        TIMER_Open(TIMER3, TIMER_PERIODIC_MODE, 1000);
000002  4c0a              LDR      r4,|L11.44|
000004  227d              MOVS     r2,#0x7d
000006  2101              MOVS     r1,#1
000008  00d2              LSLS     r2,r2,#3
00000a  06c9              LSLS     r1,r1,#27
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       TIMER_Open
000012  6820              LDR      r0,[r4,#0]
000014  0621              LSLS     r1,r4,#24
000016  4308              ORRS     r0,r0,r1
000018  6020              STR      r0,[r4,#0]
00001a  1488              ASRS     r0,r1,#18
00001c  4904              LDR      r1,|L11.48|
00001e  6008              STR      r0,[r1,#0]
000020  6820              LDR      r0,[r4,#0]
000022  0589              LSLS     r1,r1,#22
000024  4308              ORRS     r0,r0,r1
000026  6020              STR      r0,[r4,#0]
;;;380        TIMER_EnableInt(TIMER3);
;;;381        NVIC_EnableIRQ(TMR3_IRQn);	
;;;382        TIMER_Start(TIMER3);
;;;383    }
000028  bd10              POP      {r4,pc}
;;;384    
                          ENDP

00002a  0000              DCW      0x0000
                  |L11.44|
                          DCD      0x40051020
                  |L11.48|
                          DCD      0xe000e100

                          AREA ||i.TMR2_IRQHandler||, CODE, READONLY, ALIGN=2

                  TMR2_IRQHandler PROC
;;;384    
;;;385    void TMR2_IRQHandler(void)
000000  4806              LDR      r0,|L12.28|
000002  6881              LDR      r1,[r0,#8]
000004  07c9              LSLS     r1,r1,#31
000006  0fc9              LSRS     r1,r1,#31
;;;386    {
000008  d006              BEQ      |L12.24|
00000a  2101              MOVS     r1,#1
00000c  6081              STR      r1,[r0,#8]
;;;387        if(TIMER_GetIntFlag(TIMER2) == 1)
;;;388        {
;;;389            TIMER_ClearIntFlag(TIMER2);
;;;390    		set_flag(flag_RTC,ENABLE);		
00000e  4804              LDR      r0,|L12.32|
000010  2220              MOVS     r2,#0x20
000012  7801              LDRB     r1,[r0,#0]  ; BitFlag
000014  4311              ORRS     r1,r1,r2
000016  7001              STRB     r1,[r0,#0]
                  |L12.24|
;;;391        }
;;;392    }
000018  4770              BX       lr
;;;393    
                          ENDP

00001a  0000              DCW      0x0000
                  |L12.28|
                          DCD      0x40051000
                  |L12.32|
                          DCD      ||.data||

                          AREA ||i.TMR3_IRQHandler||, CODE, READONLY, ALIGN=2

                  TMR3_IRQHandler PROC
;;;362    
;;;363    void TMR3_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
000002  4806              LDR      r0,|L13.28|
000004  6881              LDR      r1,[r0,#8]
000006  07c9              LSLS     r1,r1,#31
000008  0fc9              LSRS     r1,r1,#31
;;;364    {
00000a  d005              BEQ      |L13.24|
00000c  2101              MOVS     r1,#1
00000e  6081              STR      r1,[r0,#8]
;;;365    //	static uint32_t LOG = 0;
;;;366    //	static uint16_t CNT = 0;
;;;367    	
;;;368        if(TIMER_GetIntFlag(TIMER3) == 1)
;;;369        {
;;;370            TIMER_ClearIntFlag(TIMER3);
;;;371    		
;;;372    		timer_counter();		
000010  f7fffffe          BL       timer_counter
000014  f7fffffe          BL       loop_1ms
                  |L13.24|
;;;373    		loop();
;;;374        }
;;;375    }
000018  bd10              POP      {r4,pc}
;;;376    
                          ENDP

00001a  0000              DCW      0x0000
                  |L13.28|
                          DCD      0x40051020

                          AREA ||i.UART02_IRQHandler||, CODE, READONLY, ALIGN=2

                  UART02_IRQHandler PROC
;;;402    
;;;403    void UART02_IRQHandler(void)
000000  4802              LDR      r0,|L14.12|
;;;404    {
;;;405    
;;;406    	if ((UART_GET_INT_FLAG(UART0,UART_INTSTS_RDAINT_Msk)))
000002  69c1              LDR      r1,[r0,#0x1c]
000004  05c9              LSLS     r1,r1,#23
000006  d400              BMI      |L14.10|
;;;407    	{
;;;408            /* UART receive data available flag */
;;;409     
;;;410    	}
;;;411        else if(UART_GET_INT_FLAG(UART0, UART_INTSTS_RXTOINT_Msk)) 
000008  69c0              LDR      r0,[r0,#0x1c]
                  |L14.10|
;;;412        {
;;;413     
;;;414        }	
;;;415    }
00000a  4770              BX       lr
;;;416    
                          ENDP

                  |L14.12|
                          DCD      0x40070000

                          AREA ||i.UART0_Init||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  UART0_Init PROC
;;;416    
;;;417    void UART0_Init(void)
000000  b510              PUSH     {r4,lr}
;;;418    {
;;;419        SYS_ResetModule(UART0_RST);
000002  481e              LDR      r0,|L15.124|
000004  f7fffffe          BL       SYS_ResetModule
;;;420    
;;;421        /* Configure UART0 and set UART0 baud rate */
;;;422        UART_Open(UART0, 115200);
000008  4c1d              LDR      r4,|L15.128|
00000a  21e1              MOVS     r1,#0xe1
00000c  0249              LSLS     r1,r1,#9
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       UART_Open
;;;423    
;;;424    	/* Set UART receive time-out */
;;;425    	UART_SetTimeoutCnt(UART0, 20);
000014  2114              MOVS     r1,#0x14
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       UART_SetTimeoutCnt
;;;426    
;;;427    	/* Set UART FIFO RX interrupt trigger level to 4-bytes*/
;;;428        UART0->FIFO = ((UART0->FIFO & (~UART_FIFO_RFITL_Msk)) | UART_FIFO_RFITL_4BYTES);
00001c  68a0              LDR      r0,[r4,#8]
00001e  21f0              MOVS     r1,#0xf0
000020  4388              BICS     r0,r0,r1
000022  3010              ADDS     r0,r0,#0x10
000024  60a0              STR      r0,[r4,#8]
;;;429    
;;;430    	/* Enable UART Interrupt - */
;;;431    	UART_ENABLE_INT(UART0, UART_INTEN_RDAIEN_Msk | UART_INTEN_RXTOIEN_Msk);
000026  6860              LDR      r0,[r4,#4]
000028  2111              MOVS     r1,#0x11
00002a  4308              ORRS     r0,r0,r1
00002c  6060              STR      r0,[r4,#4]
00002e  2001              MOVS     r0,#1
000030  4914              LDR      r1,|L15.132|
000032  0300              LSLS     r0,r0,#12
000034  6008              STR      r0,[r1,#0]
;;;432    	
;;;433    	NVIC_EnableIRQ(UART02_IRQn);	
;;;434    
;;;435    	printf("\r\nCLK_GetCPUFreq : %8d\r\n",CLK_GetCPUFreq());
000036  f7fffffe          BL       CLK_GetCPUFreq
00003a  4601              MOV      r1,r0
00003c  a012              ADR      r0,|L15.136|
00003e  f7fffffe          BL       __2printf
;;;436    	printf("CLK_GetHXTFreq : %8d\r\n",CLK_GetHXTFreq());
000042  f7fffffe          BL       CLK_GetHXTFreq
000046  4601              MOV      r1,r0
000048  a016              ADR      r0,|L15.164|
00004a  f7fffffe          BL       __2printf
;;;437    	printf("CLK_GetLXTFreq : %8d\r\n",CLK_GetLXTFreq());	
00004e  f7fffffe          BL       CLK_GetLXTFreq
000052  4601              MOV      r1,r0
000054  a019              ADR      r0,|L15.188|
000056  f7fffffe          BL       __2printf
;;;438    	printf("CLK_GetPCLK0Freq : %8d\r\n",CLK_GetPCLK0Freq());
00005a  f7fffffe          BL       CLK_GetPCLK0Freq
00005e  4601              MOV      r1,r0
000060  a01c              ADR      r0,|L15.212|
000062  f7fffffe          BL       __2printf
;;;439    	printf("CLK_GetPCLK1Freq : %8d\r\n",CLK_GetPCLK1Freq());
000066  f7fffffe          BL       CLK_GetPCLK1Freq
00006a  4601              MOV      r1,r0
00006c  a020              ADR      r0,|L15.240|
00006e  f7fffffe          BL       __2printf
                  |L15.114|
;;;440    
;;;441    
;;;442    	UART_WAIT_TX_EMPTY(UART0);
000072  69a0              LDR      r0,[r4,#0x18]
000074  00c0              LSLS     r0,r0,#3
000076  d5fc              BPL      |L15.114|
;;;443    }
000078  bd10              POP      {r4,pc}
;;;444    
                          ENDP

00007a  0000              DCW      0x0000
                  |L15.124|
                          DCD      0x04000010
                  |L15.128|
                          DCD      0x40070000
                  |L15.132|
                          DCD      0xe000e100
                  |L15.136|
000088  0d0a434c          DCB      "\r\nCLK_GetCPUFreq : %8d\r\n",0
00008c  4b5f4765
000090  74435055
000094  46726571
000098  203a2025
00009c  38640d0a
0000a0  00      
0000a1  00                DCB      0
0000a2  00                DCB      0
0000a3  00                DCB      0
                  |L15.164|
0000a4  434c4b5f          DCB      "CLK_GetHXTFreq : %8d\r\n",0
0000a8  47657448
0000ac  58544672
0000b0  6571203a
0000b4  20253864
0000b8  0d0a00  
0000bb  00                DCB      0
                  |L15.188|
0000bc  434c4b5f          DCB      "CLK_GetLXTFreq : %8d\r\n",0
0000c0  4765744c
0000c4  58544672
0000c8  6571203a
0000cc  20253864
0000d0  0d0a00  
0000d3  00                DCB      0
                  |L15.212|
0000d4  434c4b5f          DCB      "CLK_GetPCLK0Freq : %8d\r\n",0
0000d8  47657450
0000dc  434c4b30
0000e0  46726571
0000e4  203a2025
0000e8  38640d0a
0000ec  00      
0000ed  00                DCB      0
0000ee  00                DCB      0
0000ef  00                DCB      0
                  |L15.240|
0000f0  434c4b5f          DCB      "CLK_GetPCLK1Freq : %8d\r\n",0
0000f4  47657450
0000f8  434c4b31
0000fc  46726571
000100  203a2025
000104  38640d0a
000108  00      
000109  00                DCB      0
00010a  00                DCB      0
00010b  00                DCB      0

                          AREA ||i.isLeapYear||, CODE, READONLY, ALIGN=1

                  isLeapYear PROC
;;;241    
;;;242    int isLeapYear(int year) 
000000  b510              PUSH     {r4,lr}
;;;243    {
;;;244    	return (year%400==0) || ((year%4==0) && (year%100!=0));
000002  21ff              MOVS     r1,#0xff
000004  4604              MOV      r4,r0                 ;243
000006  3191              ADDS     r1,r1,#0x91
000008  f7fffffe          BL       __aeabi_idivmod
00000c  2900              CMP      r1,#0
00000e  d007              BEQ      |L16.32|
000010  07a1              LSLS     r1,r4,#30
000012  d107              BNE      |L16.36|
000014  2164              MOVS     r1,#0x64
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       __aeabi_idivmod
00001c  2900              CMP      r1,#0
00001e  d001              BEQ      |L16.36|
                  |L16.32|
000020  2001              MOVS     r0,#1
;;;245    }
000022  bd10              POP      {r4,pc}
                  |L16.36|
000024  2000              MOVS     r0,#0                 ;244
000026  bd10              POP      {r4,pc}
;;;246    
                          ENDP


                          AREA ||i.loop||, CODE, READONLY, ALIGN=1

                  loop PROC
;;;330    
;;;331    void loop(void)
000000  b500              PUSH     {lr}
;;;332    {
;;;333    	loop_1ms();
000002  f7fffffe          BL       loop_1ms
;;;334    }
000006  bd00              POP      {pc}
;;;335    
                          ENDP


                          AREA ||i.loop_1ms||, CODE, READONLY, ALIGN=2

                  loop_1ms PROC
;;;311    
;;;312    void loop_1ms(void)
000000  490a              LDR      r1,|L18.44|
;;;313    {
;;;314    	static uint16_t CNT = 1;
;;;315    //	static uint16_t LOG = 0;
;;;316    
;;;317    	if (is_flag_set(flag_1ms))
000002  7808              LDRB     r0,[r1,#0]  ; BitFlag
000004  07c2              LSLS     r2,r0,#31
000006  d00f              BEQ      |L18.40|
;;;318    	{		
;;;319    		set_flag(flag_1ms,DISABLE);
000008  0840              LSRS     r0,r0,#1
00000a  0040              LSLS     r0,r0,#1
00000c  7008              STRB     r0,[r1,#0]
;;;320    		
;;;321    		if (CNT++ == (TIMER_1S/TIMER_1MS))
00000e  8948              LDRH     r0,[r1,#0xa]  ; CNT
000010  1c42              ADDS     r2,r0,#1
000012  814a              STRH     r2,[r1,#0xa]
000014  227d              MOVS     r2,#0x7d
000016  00d2              LSLS     r2,r2,#3
000018  4290              CMP      r0,r2
00001a  d105              BNE      |L18.40|
;;;322    		{
;;;323    			CNT = 1;
00001c  2001              MOVS     r0,#1
00001e  8148              STRH     r0,[r1,#0xa]
;;;324    //			printf("%s : %4d\r\n",__FUNCTION__,LOG++);
;;;325    
;;;326    			PB14 ^= 1;
000020  4903              LDR      r1,|L18.48|
000022  6b8a              LDR      r2,[r1,#0x38]
000024  4042              EORS     r2,r2,r0
000026  638a              STR      r2,[r1,#0x38]
                  |L18.40|
;;;327    		}		
;;;328    	}
;;;329    }
000028  4770              BX       lr
;;;330    
                          ENDP

00002a  0000              DCW      0x0000
                  |L18.44|
                          DCD      ||.data||
                  |L18.48|
                          DCD      0x40004840

                          AREA ||i.main||, CODE, READONLY, ALIGN=1

                  main PROC
;;;492    
;;;493    int main()
000000  f7fffffe          BL       SYS_Init
;;;494    {
;;;495        SYS_Init();
;;;496    
;;;497        UART0_Init();
000004  f7fffffe          BL       UART0_Init
;;;498    
;;;499    	GPIO_Init();
000008  f7fffffe          BL       GPIO_Init
;;;500    
;;;501    	TIMER2_Init();
00000c  f7fffffe          BL       TIMER2_Init
;;;502    
;;;503    	TIMER3_Init();
000010  f7fffffe          BL       TIMER3_Init
;;;504    
;;;505    	Emulate_EEPROM();
000014  f7fffffe          BL       Emulate_EEPROM
;;;506    	GetDateTimeFromFlash();
000018  f7fffffe          BL       GetDateTimeFromFlash
                  |L19.28|
;;;507    	
;;;508        /* Got no where to go, just loop forever */
;;;509        while(1)
;;;510        {		
;;;511    		RTC_Process();
00001c  f7fffffe          BL       RTC_Process
;;;512    		SaveDateTimeToFlash();
000020  f7fffffe          BL       SaveDateTimeToFlash
000024  e7fa              B        |L19.28|
;;;513        }
;;;514    }
;;;515    
                          ENDP


                          AREA ||i.set_data_flash_base||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  set_data_flash_base PROC
;;;177    
;;;178    int set_data_flash_base(uint32_t u32DFBA)
000000  b57c              PUSH     {r2-r6,lr}
;;;179    {
000002  4604              MOV      r4,r0
;;;180        uint32_t   au32Config[2];
;;;181    	
;;;182        /* Read User Configuration 0 & 1 */
;;;183        if (FMC_ReadConfig(au32Config, 2) < 0)
000004  2102              MOVS     r1,#2
000006  4668              MOV      r0,sp
000008  f7fffffe          BL       FMC_ReadConfig
;;;184        {
;;;185            printf("\nRead User Config failed!\n");
;;;186            return -1;
00000c  2500              MOVS     r5,#0
00000e  43ed              MVNS     r5,r5
000010  2800              CMP      r0,#0                 ;183
000012  da03              BGE      |L20.28|
000014  a01e              ADR      r0,|L20.144|
000016  f7fffffe          BL       __2printf
00001a  e017              B        |L20.76|
                  |L20.28|
;;;187        }
;;;188    
;;;189        /* Check if Data Flash is enabled (CONFIG0[0]) and is expected address (CONFIG1) */
;;;190        if ((!(au32Config[0] & 0x1)) && (au32Config[1] == u32DFBA))
00001c  9800              LDR      r0,[sp,#0]
00001e  07c0              LSLS     r0,r0,#31
000020  d104              BNE      |L20.44|
000022  9801              LDR      r0,[sp,#4]
000024  42a0              CMP      r0,r4
000026  d101              BNE      |L20.44|
                  |L20.40|
;;;191            return 0;
000028  2000              MOVS     r0,#0
;;;192    
;;;193        FMC_ENABLE_CFG_UPDATE();
;;;194    
;;;195        au32Config[0] &= ~0x1;         /* CONFIG0[0] = 0 (Enabled) / 1 (Disabled) */
;;;196        au32Config[1] = u32DFBA;
;;;197    
;;;198        /* Update User Configuration settings. */
;;;199        if (FMC_WriteConfig(au32Config, 2) < 0)
;;;200            return -1;
;;;201    
;;;202        FMC_ReadConfig(au32Config, 2);
;;;203    
;;;204        /* Check if Data Flash is enabled (CONFIG0[0]) and is expected address (CONFIG1) */
;;;205        if (((au32Config[0] & 0x01) == 1) || (au32Config[1] != u32DFBA))
;;;206        {
;;;207            printf("Error: Program Config Failed!\n");
;;;208            /* Disable FMC ISP function */
;;;209            FMC_Close();
;;;210            SYS_LockReg();
;;;211            return -1;
;;;212        }
;;;213    
;;;214    
;;;215        printf("\nSet Data Flash base as 0x%x.\n", u32DFBA);
;;;216    
;;;217        /* To check if all the debug messages are finished */
;;;218        while(!IsDebugFifoEmpty());
;;;219    
;;;220        /* Perform chip reset to make new User Config take effect */
;;;221        SYS->IPRST0 = SYS_IPRST0_CHIPRST_Msk;
;;;222        return 0;
;;;223    }
00002a  bd7c              POP      {r2-r6,pc}
                  |L20.44|
00002c  481f              LDR      r0,|L20.172|
00002e  6801              LDR      r1,[r0,#0]            ;193
000030  2210              MOVS     r2,#0x10              ;193
000032  4311              ORRS     r1,r1,r2              ;193
000034  6001              STR      r1,[r0,#0]            ;193
000036  9800              LDR      r0,[sp,#0]            ;195
000038  2102              MOVS     r1,#2                 ;199
00003a  0840              LSRS     r0,r0,#1              ;195
00003c  0040              LSLS     r0,r0,#1              ;195
00003e  9000              STR      r0,[sp,#0]            ;199
000040  9401              STR      r4,[sp,#4]            ;199
000042  4668              MOV      r0,sp                 ;199
000044  f7fffffe          BL       FMC_WriteConfig
000048  2800              CMP      r0,#0                 ;199
00004a  da01              BGE      |L20.80|
                  |L20.76|
00004c  4628              MOV      r0,r5                 ;200
00004e  bd7c              POP      {r2-r6,pc}
                  |L20.80|
000050  2102              MOVS     r1,#2                 ;202
000052  4668              MOV      r0,sp                 ;202
000054  f7fffffe          BL       FMC_ReadConfig
000058  9800              LDR      r0,[sp,#0]            ;205
00005a  07c0              LSLS     r0,r0,#31             ;205
00005c  d102              BNE      |L20.100|
00005e  9801              LDR      r0,[sp,#4]            ;205
000060  42a0              CMP      r0,r4                 ;205
000062  d008              BEQ      |L20.118|
                  |L20.100|
000064  a012              ADR      r0,|L20.176|
000066  f7fffffe          BL       __2printf
00006a  f7fffffe          BL       FMC_Close
00006e  4918              LDR      r1,|L20.208|
000070  2000              MOVS     r0,#0                 ;209
000072  6008              STR      r0,[r1,#0]            ;209
000074  e7ea              B        |L20.76|
                  |L20.118|
000076  4621              MOV      r1,r4                 ;215
000078  a016              ADR      r0,|L20.212|
00007a  f7fffffe          BL       __2printf
                  |L20.126|
00007e  f7fffffe          BL       IsDebugFifoEmpty
000082  2800              CMP      r0,#0                 ;218
000084  d0fb              BEQ      |L20.126|
000086  2001              MOVS     r0,#1                 ;221
000088  0781              LSLS     r1,r0,#30             ;221
00008a  6088              STR      r0,[r1,#8]            ;221
00008c  e7cc              B        |L20.40|
;;;224    
                          ENDP

00008e  0000              DCW      0x0000
                  |L20.144|
000090  0a526561          DCB      "\nRead User Config failed!\n",0
000094  64205573
000098  65722043
00009c  6f6e6669
0000a0  67206661
0000a4  696c6564
0000a8  210a00  
0000ab  00                DCB      0
                  |L20.172|
                          DCD      0x4000c000
                  |L20.176|
0000b0  4572726f          DCB      "Error: Program Config Failed!\n",0
0000b4  723a2050
0000b8  726f6772
0000bc  616d2043
0000c0  6f6e6669
0000c4  67204661
0000c8  696c6564
0000cc  210a00  
0000cf  00                DCB      0
                  |L20.208|
                          DCD      0x40000100
                  |L20.212|
0000d4  0a536574          DCB      "\nSet Data Flash base as 0x%x.\n",0
0000d8  20446174
0000dc  6120466c
0000e0  61736820
0000e4  62617365
0000e8  20617320
0000ec  30782578
0000f0  2e0a00  
0000f3  00                DCB      0

                          AREA ||i.timer_counter||, CODE, READONLY, ALIGN=2

                  timer_counter PROC
;;;335    
;;;336    void timer_counter(void)
000000  b570              PUSH     {r4-r6,lr}
;;;337    {
;;;338    	conter_1ms ++;
000002  4d1b              LDR      r5,|L21.112|
;;;339    	
;;;340    	set_flag(flag_1ms,ENABLE);
000004  2101              MOVS     r1,#1
000006  8928              LDRH     r0,[r5,#8]            ;338  ; conter_1ms
000008  1c40              ADDS     r0,r0,#1              ;338
00000a  b280              UXTH     r0,r0                 ;338
00000c  8128              STRH     r0,[r5,#8]            ;338
00000e  782c              LDRB     r4,[r5,#0]  ; BitFlag
000010  4606              MOV      r6,r0                 ;338
000012  430c              ORRS     r4,r4,r1
000014  702c              STRB     r4,[r5,#0]
;;;341    	
;;;342    	if(!(conter_1ms %TIMER_5MS)){
000016  2105              MOVS     r1,#5
000018  f7fffffe          BL       __aeabi_uidivmod
00001c  2900              CMP      r1,#0
00001e  d102              BNE      |L21.38|
;;;343    		set_flag(flag_5ms,ENABLE);}
000020  2002              MOVS     r0,#2
000022  4304              ORRS     r4,r4,r0
000024  702c              STRB     r4,[r5,#0]
                  |L21.38|
;;;344    	
;;;345    	if(!(conter_1ms %TIMER_10MS)){
000026  210a              MOVS     r1,#0xa
000028  4630              MOV      r0,r6
00002a  f7fffffe          BL       __aeabi_uidivmod
00002e  2900              CMP      r1,#0
000030  d103              BNE      |L21.58|
;;;346    		set_flag(flag_10ms,ENABLE);}
000032  7828              LDRB     r0,[r5,#0]  ; BitFlag
000034  2104              MOVS     r1,#4
000036  4308              ORRS     r0,r0,r1
000038  7028              STRB     r0,[r5,#0]
                  |L21.58|
;;;347    	
;;;348    	if(!(conter_1ms %TIMER_50MS)){
00003a  2132              MOVS     r1,#0x32
00003c  4630              MOV      r0,r6
00003e  f7fffffe          BL       __aeabi_uidivmod
000042  2900              CMP      r1,#0
000044  d103              BNE      |L21.78|
;;;349    		set_flag(flag_50ms,ENABLE);}
000046  7828              LDRB     r0,[r5,#0]  ; BitFlag
000048  2108              MOVS     r1,#8
00004a  4308              ORRS     r0,r0,r1
00004c  7028              STRB     r0,[r5,#0]
                  |L21.78|
;;;350    	
;;;351    	if(!(conter_1ms %TIMER_100MS)){
00004e  2164              MOVS     r1,#0x64
000050  4630              MOV      r0,r6
000052  f7fffffe          BL       __aeabi_uidivmod
000056  2900              CMP      r1,#0
000058  d103              BNE      |L21.98|
;;;352    		set_flag(flag_100ms,ENABLE);}
00005a  7828              LDRB     r0,[r5,#0]  ; BitFlag
00005c  2110              MOVS     r1,#0x10
00005e  4308              ORRS     r0,r0,r1
000060  7028              STRB     r0,[r5,#0]
                  |L21.98|
;;;353    
;;;354    	if(conter_1ms >= 65500){
000062  4804              LDR      r0,|L21.116|
000064  4286              CMP      r6,r0
000066  d301              BCC      |L21.108|
;;;355    		conter_1ms = 0;}
000068  2000              MOVS     r0,#0
00006a  8128              STRH     r0,[r5,#8]
                  |L21.108|
;;;356    }
00006c  bd70              POP      {r4-r6,pc}
;;;357    
                          ENDP

00006e  0000              DCW      0x0000
                  |L21.112|
                          DCD      ||.data||
                  |L21.116|
                          DCD      0x0000ffdc

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  __FUNCTION__
000000  53617665          DCB      0x53,0x61,0x76,0x65
000004  44617465          DCB      0x44,0x61,0x74,0x65
000008  54696d65          DCB      0x54,0x69,0x6d,0x65
00000c  546f466c          DCB      0x54,0x6f,0x46,0x6c
000010  61736800          DCB      0x61,0x73,0x68,0x00
                          DCD      0x0000001f
                          DCD      0x0000001c
                          DCD      0x0000001f
                          DCD      0x0000001e
                          DCD      0x0000001f
                          DCD      0x0000001e
                          DCD      0x0000001f
                          DCD      0x0000001f
                          DCD      0x0000001e
                          DCD      0x0000001f
                          DCD      0x0000001e
                          DCD      0x0000001f

                          AREA ||.data||, DATA, ALIGN=2

                  BitFlag
000000  00                DCB      0x00
                  g_month
000001  04                DCB      0x04
                  g_day
000002  1b                DCB      0x1b
                  g_weekly
000003  01                DCB      0x01
                  hour
000004  0d                DCB      0x0d
                  min
000005  3b                DCB      0x3b
                  ||sec||
000006  1e                DCB      0x1e
                  g_day_old
000007  00                DCB      0x00
                  conter_1ms
000008  0000              DCW      0x0000
                  ||CNT||
00000a  0001              DCW      0x0001
                  g_year
                          DCD      0x000007e4

;*** Start embedded assembler ***

#line 1 "..\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_BitFlag____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_main_c_BitFlag____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_BitFlag____REVSH|
#line 402
|__asm___6_main_c_BitFlag____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
